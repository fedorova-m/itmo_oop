# Отчет по Лабораторной работе №3: Управление заказами в службе доставки

## Общее описание проекта

Данное консольное приложение представляет собой систему управления заказами для службы доставки еды. Оно демонстрирует использование пяти паттернов проектирования: State, Strategy, Builder, Abstract Factory и Observer, а также соблюдение принципов SOLID.

**Основные функции системы:**

- Создание и управление заказами различных типов (стандартные, с быстрой доставкой, с персональными предпочтениями)
- Выбор блюд из меню
- Отслеживание состояния заказа (подготовка, доставка, выполнен)
- Расчет стоимости заказа с учетом различных факторов (скидки, налоги, плата за доставку)
- Уведомления клиентов об изменении состояния заказа

## Структура проекта

```
lab_3/
├── Program.cs                    # Точка входа в приложение
├── homework3.csproj             # Файл проекта
├── core/                        # Основные классы системы
│   ├── Dishes/                  # Классы блюд
│   │   └── Dish.cs              # Класс блюда
│   ├── Orders/                  # Классы заказов
│   │   ├── Order.cs             # Абстрактный базовый класс Order
│   │   ├── StandardOrder.cs     # Стандартный заказ
│   │   ├── ExpressOrder.cs      # Заказ с быстрой доставкой
│   │   ├── CustomOrder.cs       # Заказ с персональными предпочтениями
│   │   └── OrderManager.cs      # Менеджер заказов
│   └── Patterns/                # Паттерны проектирования
│       ├── State/               # Паттерн State
│       │   ├── IOrderState.cs   # Интерфейс состояния заказа
│       │   ├── PreparingState.cs # Состояние "Подготовка"
│       │   ├── DeliveringState.cs # Состояние "Доставка"
│       │   └── CompletedState.cs  # Состояние "Выполнен"
│       ├── Strategy/            # Паттерн Strategy
│       │   ├── IPricingStrategy.cs # Интерфейс стратегии расчета
│       │   ├── StandardPricingStrategy.cs # Стандартная стратегия
│       │   ├── DiscountPricingStrategy.cs # Стратегия со скидкой
│       │   └── NoDeliveryFeeStrategy.cs # Стратегия без доставки
│       ├── Builder/             # Паттерн Builder
│       │   └── OrderBuilder.cs  # Строитель заказов
│       ├── AbstractFactory/     # Паттерн Abstract Factory
│       │   ├── IOrderFactory.cs # Интерфейс фабрики заказов
│       │   └── OrderFactory.cs  # Фабрика заказов
│       └── Observer/            # Паттерн Observer
│           ├── IOrderObserver.cs # Интерфейс наблюдателя
│           ├── OrderNotifier.cs  # Уведомитель
│           └── CustomerNotification.cs # Уведомление клиенту
└── Tests/                       # Unit тесты
    └── OrderTests.cs            # Тесты для всех компонентов системы
```

## Основные компоненты системы

### Классы заказов

- **`Order`** - абстрактный базовый класс, определяющий общую структуру всех заказов. Содержит свойства `Id`, `CustomerName`, `Items` и интегрирует паттерн State через поле `_state`. Методы: `CalculateBasePrice()` (абстрактный), `GetOrderType()` (абстрактный), методы работы с состоянием.

- **`StandardOrder`** - стандартный заказ. Базовая цена рассчитывается как сумма стоимости всех блюд.

- **`ExpressOrder`** - заказ с быстрой доставкой. К базовой цене добавляется плата за быструю доставку (50 руб.).

- **`CustomOrder`** - заказ с персональными предпочтениями. Содержит свойство `SpecialInstructions` и добавляет плату за персональные предпочтения (30 руб.).

### Класс OrderManager

Управляет коллекцией заказов. Основные методы:

- `AddOrder(Order order)` - добавление заказа
- `GetOrder(int id)` - получение заказа по ID
- `ProcessOrder(int id)` - обработка заказа (переход в состояние "Подготовка")
- `DeliverOrder(int id)` - отправка заказа на доставку
- `CompleteOrder(int id)` - завершение заказа
- `CalculateOrderPrice(int id, IPricingStrategy strategy)` - расчет стоимости с выбранной стратегией

## Паттерны проектирования в проекте

### 1. State Pattern (Паттерн Состояние)

**Определение:** Позволяет объекту изменять свое поведение при изменении внутреннего состояния.

**Реализация:**

- Интерфейс `IOrderState` с методами `Process()`, `Deliver()`, `Complete()`, `GetStateName()`
- Реализации: `PreparingState` (подготовка), `DeliveringState` (доставка), `CompletedState` (выполнен)
- Использование в классе `Order` через поле `_state`

**Обоснование:** Заказы проходят через различные состояния (подготовка → доставка → выполнен), и поведение заказа зависит от его текущего состояния. Паттерн State позволяет инкапсулировать логику каждого состояния в отдельные классы, избегая больших условных операторов.

**Диаграмма переходов состояний:**

```
     Подготовка (PreparingState)
        │
        │ Deliver()
        ▼
     Доставка (DeliveringState)
        │
        │ Complete()
        ▼
     Выполнен (CompletedState)
```

### 2. Strategy Pattern (Паттерн Стратегия)

**Определение:** Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.

**Реализация:**

- Интерфейс `IPricingStrategy` с методом `CalculateFinalPrice(Order order)`
- Реализации: `StandardPricingStrategy` (стандартная с налогом и доставкой), `DiscountPricingStrategy` (со скидкой), `NoDeliveryFeeStrategy` (без платы за доставку)
- Использование в `OrderManager.CalculateOrderPrice()`

**Обоснование:** Расчет стоимости заказа может выполняться по разным правилам (со скидкой, без доставки, с налогом и т.д.). Паттерн Strategy позволяет легко добавлять новые стратегии расчета без изменения существующего кода, соблюдая принцип Open/Closed.

### 3. Builder Pattern (Паттерн Строитель)

**Определение:** Отделяет конструирование сложного объекта от его представления.

**Реализация:**

- Класс `OrderBuilder` с методами `SetId()`, `SetCustomerName()`, `SetOrderType()`, `AddItem()`, `Build()`
- Fluent Interface (цепочка вызовов) через `return this`
- Валидация данных в методе `Build()`

**Обоснование:** Создание заказа требует установки множества параметров (ID, имя клиента, тип заказа, список блюд). Builder Pattern позволяет создавать заказы пошагово с валидацией данных, обеспечивая создание только валидных объектов.

### 4. Abstract Factory Pattern (Паттерн Абстрактная Фабрика)

**Определение:** Предоставляет интерфейс для создания семейств связанных объектов без указания их конкретных классов.

**Реализация:**

- Интерфейс `IOrderFactory` с методами `CreateStandardOrder()`, `CreateExpressOrder()`, `CreateCustomOrder()`
- Реализация `OrderFactory` для создания различных типов заказов

**Обоснование:** Система должна создавать различные типы заказов (стандартные, экспресс, с персональными предпочтениями). Abstract Factory Pattern инкапсулирует логику создания заказов, позволяя легко добавлять новые типы заказов в будущем.

### 5. Observer Pattern (Паттерн Наблюдатель)

**Определение:** Определяет зависимость "один ко многим" между объектами так, что при изменении состояния одного объекта все зависящие от него объекты получают уведомление.

**Реализация:**

- Интерфейс `IOrderObserver` с методом `Update(Order order, string message)`
- Класс `OrderNotifier` для управления наблюдателями
- Реализация `CustomerNotification` для уведомления клиентов
- Использование в `OrderManager` для уведомления об изменениях состояния заказов

**Обоснование:** При изменении состояния заказа (подготовка, доставка, выполнен) необходимо уведомлять клиентов. Observer Pattern позволяет легко добавлять новые типы уведомлений (SMS, email, push) без изменения логики заказов, соблюдая принцип разделения ответственности.

## Принципы SOLID в проекте

### S - Single Responsibility Principle

Каждый класс имеет одну ответственность:

- `OrderManager` - управление коллекцией заказов
- `PreparingState` - поведение заказа в состоянии "Подготовка"
- `StandardPricingStrategy` - расчет стоимости по стандартным правилам
- `OrderBuilder` - создание заказов с валидацией

### O - Open/Closed Principle

Классы открыты для расширения, закрыты для модификации:

- Можно добавлять новые стратегии расчета без изменения `OrderManager`
- Можно добавлять новые состояния без изменения `Order`
- Можно добавлять новые типы заказов через Abstract Factory
- Можно добавлять новые наблюдатели без изменения `OrderNotifier`

### L - Liskov Substitution Principle

Объекты заменяются экземплярами их подтипов:

- `StandardOrder`, `ExpressOrder`, `CustomOrder` используются везде, где ожидается `Order`
- `PreparingState`, `DeliveringState`, `CompletedState` взаимозаменяемы
- `StandardPricingStrategy`, `DiscountPricingStrategy`, `NoDeliveryFeeStrategy` взаимозаменяемы

### I - Interface Segregation Principle

Интерфейсы маленькие и сфокусированные:

- `IOrderState` - методы для работы с состояниями
- `IPricingStrategy` - один метод расчета стоимости
- `IOrderObserver` - один метод обновления

### D - Dependency Inversion Principle

Зависимости на абстракциях, а не на конкретных реализациях:

- `OrderManager` зависит от `IPricingStrategy` (интерфейс)
- `Order` зависит от `IOrderState` (интерфейс)
- `OrderNotifier` зависит от `IOrderObserver` (интерфейс)

## Unit тестирование

Проект включает **16 unit тестов**, написанных с использованием фреймворка xUnit, которые покрывают:

- **Заказы:** создание, расчет базовой цены для различных типов заказов
- **Состояния:** переходы между состояниями заказа
- **Стратегии:** расчет стоимости с различными стратегиями
- **Builder:** создание заказов через билдер, валидация данных
- **Abstract Factory:** создание различных типов заказов
- **OrderManager:** добавление заказов, обработка состояний

**Запуск тестов:**

```bash
dotnet test
```

## Обработка ошибок и валидация

- **Валидация в Builder:** `OrderBuilder.Build()` проверяет валидность данных, выбрасывая исключения при ошибках
- **Проверка существования заказов:** методы `OrderManager` проверяют наличие заказа перед операциями
- **Информативные сообщения:** понятные сообщения об ошибках для пользователя
- **Защита от невалидных состояний:** состояния проверяют условия перед изменением

## Используемые технологии и библиотеки

- **C# .NET 10.0** - основной язык и платформа
- **xUnit** - фреймворк для unit тестирования
- **Console I/O** - для вывода информации в консоль
- **Implicit Usings** - автоматический импорт базовых пространств имен

## Итоги

Система демонстрирует комплексное использование паттернов проектирования и принципов SOLID:

- **State Pattern** для управления состояниями заказов и изменения их поведения
- **Strategy Pattern** для выбора алгоритма расчета стоимости во время выполнения
- **Builder Pattern** для пошагового создания заказов с валидацией
- **Abstract Factory Pattern** для создания различных типов заказов
- **Observer Pattern** для уведомления клиентов об изменениях состояния заказов

Проект полностью покрыт unit тестами (16 тестов), что обеспечивает надежность и поддерживаемость кода. Код написан с соблюдением принципов SOLID, что делает его гибким, расширяемым и легко тестируемым.
