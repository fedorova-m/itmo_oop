# Отчет по Лабораторной работе №2: Управление инвентарем в ролевой игре

## Общее описание проекта

Данное консольное приложение представляет собой систему управления инвентарем для игрового приложения. Оно демонстрирует использование четырех паттернов проектирования: Strategy, State, Builder и Abstract Factory, а также соблюдение принципов SOLID.

**Основные функции системы:**

- Управление предметами в инвентаре (добавление, просмотр, использование)
- Различные типы предметов: оружие, броня, зелья, квестовые предметы
- Система состояний предметов (Новый, Использованный, Сломанный)
- Различные стратегии использования предметов (экипировка, выпивание, нельзя использовать)
- Создание предметов через фабрики и билдеры
- Улучшение предметов с изменением их состояния

## Структура проекта

```
lab_2/
├── Program.cs                    # Точка входа в приложение
├── homework2.csproj             # Файл проекта
├── core/                        # Основные классы системы
│   ├── Items/                   # Классы предметов
│   │   ├── Item.cs              # Абстрактный базовый класс Item
│   │   ├── Weapon.cs            # Класс для оружия
│   │   ├── Armor.cs             # Класс для брони
│   │   ├── Potion.cs            # Класс для зелий
│   │   └── QuestItem.cs         # Класс для квестовых предметов
│   ├── Inventory/               # Управление инвентарем
│   │   └── Inventory.cs        # Класс для управления коллекцией предметов
│   └── Patterns/                # Паттерны проектирования
│       ├── Strategy/            # Паттерн Strategy
│       ├── State/               # Паттерн State
│       ├── Builder/             # Паттерн Builder
│       └── AbstractFactory/     # Паттерн Abstract Factory
└── Tests/                       # Unit тесты
    └── InventoryTests.cs        # Тесты для всех компонентов системы
```

## Основные компоненты системы

### Классы предметов

- **`Item`** - абстрактный базовый класс, определяющий общую структуру всех предметов. Содержит свойства `Name`, `Level`, `UseCount` и интегрирует паттерн State через поле `_state`. Методы: `Use()` (абстрактный), `Upgrade()` (виртуальный), методы работы с состоянием.

- **`Weapon`** - класс оружия с свойством `Damage`. При использовании экипируется и меняет состояние.

- **`Armor`** - класс брони с свойством `Defense`. При использовании экипируется и меняет состояние.

- **`Potion`** - класс зелий с свойством `Effect`. При использовании применяет эффект и меняет состояние.

- **`QuestItem`** - класс квестовых предметов с свойством `QuestDescription`. Не меняет состояние при использовании, только выводит информацию о квесте.

### Класс Inventory

Управляет коллекцией предметов. Основные методы:

- `AddItem(Item item)` - добавление предмета
- `ShowItems()` - отображение всех предметов
- `UseItem(string name, IUseStrategy strategy)` - использование предмета с выбранной стратегией
- `UpgradeItem(string name)` - улучшение предмета

## Паттерны проектирования в проекте

### 1. Strategy Pattern (Паттерн Стратегия)

**Определение:** Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.

**Реализация:**

- Интерфейс `IUseStrategy` с методом `Execute(Item item)`
- Реализации: `EquipStrategy` (экипировка оружия/брони), `DrinkStrategy` (выпивание зелий), `NoUseStrategy` (нельзя использовать)
- Использование в `Inventory.UseItem()` для выбора алгоритма использования во время выполнения

**Преимущества:** Можно добавлять новые стратегии без изменения `Inventory`, соблюдается принцип Open/Closed.

### 2. State Pattern (Паттерн Состояние)

**Определение:** Позволяет объекту изменять свое поведение при изменении внутреннего состояния.

**Реализация:**

- Интерфейс `IItemState` с методами `Use()`, `Upgrade()`, `GetStateName()`
- Реализации: `NewState` (новый предмет), `UsedState` (использованный), `BrokenState` (сломанный)
- Использование в классе `Item` через поле `_state`

**Диаграмма переходов состояний:**

```
     Новый (NewState)
        │
        │ Use()
        ▼
  Использованный (UsedState)
        │
        │ Use() (3 раза)
        ▼
    Сломанный (BrokenState)
        │
        │ Upgrade()
        ▼
     Новый (NewState)
```

**Преимущества:** Избегает больших условных операторов, легко добавлять новые состояния, каждое состояние инкапсулирует свою логику.

### 3. Builder Pattern (Паттерн Строитель)

**Определение:** Отделяет конструирование сложного объекта от его представления.

**Реализация:**

- Класс `WeaponBuilder` с методами `SetName()`, `SetDamage()`, `Build()`
- Fluent Interface (цепочка вызовов) через `return this`
- Валидация данных в методе `Build()` перед возвратом объекта

**Преимущества:** Пошаговое создание объекта, валидация данных, удобный синтаксис, нельзя создать невалидный объект.

### 4. Abstract Factory Pattern (Паттерн Абстрактная Фабрика)

**Определение:** Предоставляет интерфейс для создания семейств связанных объектов без указания их конкретных классов.

**Реализация:**

- Интерфейс `IItemFactory` с методами `CreateWeapon()`, `CreateArmor()`, `CreatePotion()`
- Реализации: `NoviceItemFactory` (простые предметы для новичков), `MageItemFactory` (предметы для магов)

**Преимущества:** Создание связанных объектов (семейств), легко добавлять новые семейства, изоляция создания объектов от использования.

## Принципы SOLID в проекте

### S - Single Responsibility Principle

Каждый класс имеет одну ответственность:

- `Inventory` - управление коллекцией предметов
- `NewState` - поведение предмета в состоянии "Новый"
- `EquipStrategy` - логика экипировки
- `WeaponBuilder` - создание оружия с валидацией

### O - Open/Closed Principle

Классы открыты для расширения, закрыты для модификации:

- Можно добавлять новые стратегии без изменения `Inventory`
- Можно добавлять новые состояния без изменения `Item`
- Можно добавлять новые фабрики без изменения интерфейса `IItemFactory`

### L - Liskov Substitution Principle

Объекты заменяются экземплярами их подтипов:

- `Weapon`, `Armor`, `Potion`, `QuestItem` используются везде, где ожидается `Item`
- `NewState`, `UsedState`, `BrokenState` взаимозаменяемы
- `EquipStrategy`, `DrinkStrategy`, `NoUseStrategy` взаимозаменяемы

### I - Interface Segregation Principle

Интерфейсы маленькие и сфокусированные:

- `IUseStrategy` - один метод `Execute()`
- `IItemState` - три метода, все используются состояниями
- `IItemFactory` - три метода, все используются фабриками

### D - Dependency Inversion Principle

Зависимости на абстракциях, а не на конкретных реализациях:

- `Inventory` зависит от `IUseStrategy` (интерфейс)
- `Item` зависит от `IItemState` (интерфейс)
- `Program` использует `IItemFactory` (интерфейс)

## Unit тестирование

Проект включает **более 30 unit тестов**, написанных с использованием фреймворка xUnit, которые покрывают:

- **Предметы:** создание, использование, изменение состояний (Weapon, Armor, Potion, QuestItem)
- **Инвентарь:** добавление, отображение, использование, улучшение предметов
- **Стратегии:** EquipStrategy, DrinkStrategy, NoUseStrategy
- **Builder:** создание оружия, валидация данных
- **Abstract Factory:** создание предметов через NoviceItemFactory и MageItemFactory
- **Состояния:** переходы между состояниями, логика улучшения и использования
- **Интеграционные тесты:** совместная работа паттернов

**Запуск тестов:**

```bash
dotnet test
```

## Обработка ошибок и валидация

- **Валидация в Builder:** `WeaponBuilder.Build()` проверяет валидность данных, выбрасывая исключения при ошибках
- **Проверка существования предметов:** методы `Inventory` проверяют наличие предмета перед использованием
- **Безопасные вызовы:** использование оператора `?.` (null-conditional) для безопасного вызова методов
- **Информативные сообщения:** понятные сообщения об ошибках для пользователя
- **Защита от невалидных состояний:** состояния проверяют условия перед изменением

## Используемые технологии и библиотеки

- **C# .NET 10.0** - основной язык и платформа
- **xUnit** - фреймворк для unit тестирования
- **Console I/O** - для вывода информации в консоль
- **Implicit Usings** - автоматический импорт базовых пространств имен

## Итоги

Система демонстрирует комплексное использование паттернов проектирования и принципов SOLID:

- **Strategy Pattern** для выбора алгоритма использования предметов во время выполнения
- **State Pattern** для управления состояниями предметов и изменения их поведения
- **Builder Pattern** для пошагового создания объектов с валидацией
- **Abstract Factory Pattern** для создания семейств связанных предметов

Проект полностью покрыт unit тестами (более 30 тестов), что обеспечивает надежность и поддерживаемость кода. Код написан с соблюдением принципов SOLID, что делает его гибким, расширяемым и легко тестируемым.
