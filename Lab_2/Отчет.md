# Отчет по Лабораторной работе №2: Система управления инвентарем с паттернами проектирования

## Общее описание проекта

Данное консольное приложение представляет собой систему управления инвентарем для игрового приложения. Оно демонстрирует использование четырех паттернов проектирования (Design Patterns): Strategy, State, Builder и Abstract Factory, а также соблюдение принципов SOLID.

**Основные функции системы:**

- Управление предметами в инвентаре (добавление, просмотр, использование)
- Различные типы предметов: оружие, броня, зелья, квестовые предметы
- Система состояний предметов (Новый, Использованный, Сломанный)
- Различные стратегии использования предметов (экипировка, выпивание, нельзя использовать)
- Создание предметов через фабрики и билдеры
- Улучшение предметов с изменением их состояния

## Структура проекта

Проект организован следующим образом:

```
lab_2/
├── Program.cs                    # Точка входа в приложение
├── homework2.csproj             # Файл проекта
├── core/                        # Основные классы системы
│   ├── Items/                   # Классы предметов
│   │   ├── Item.cs              # Абстрактный базовый класс Item
│   │   ├── Weapon.cs            # Класс для оружия
│   │   ├── Armor.cs             # Класс для брони
│   │   ├── Potion.cs            # Класс для зелий
│   │   └── QuestItem.cs         # Класс для квестовых предметов
│   ├── Inventory/               # Управление инвентарем
│   │   └── Inventory.cs        # Класс для управления коллекцией предметов
│   └── Patterns/                # Паттерны проектирования
│       ├── Strategy/            # Паттерн Strategy
│       │   ├── IUseStrategy.cs  # Интерфейс стратегии использования
│       │   ├── EquipStrategy.cs # Стратегия экипировки
│       │   ├── DrinkStrategy.cs # Стратегия выпивания зелий
│       │   └── NoUseStrategy.cs # Стратегия "нельзя использовать"
│       ├── State/               # Паттерн State
│       │   ├── IItemState.cs    # Интерфейс состояния предмета
│       │   ├── NewState.cs     # Состояние "Новый"
│       │   ├── UsedState.cs    # Состояние "Использованный"
│       │   └── BrokenState.cs  # Состояние "Сломанный"
│       ├── Builder/             # Паттерн Builder
│       │   └── WeaponBuilder.cs # Строитель для создания оружия
│       └── AbstractFactory/     # Паттерн Abstract Factory
│           ├── IItemFactory.cs  # Интерфейс фабрики предметов
│           ├── NoviceItemFactory.cs # Фабрика для новичков
│           └── MageItemFactory.cs   # Фабрика для магов
└── Tests/                       # Unit тесты
    └── InventoryTests.cs        # Тесты для всех компонентов системы
```

## Детальное объяснение кода по файлам

### Файл `Program.cs` - точка входа в приложение

**Назначение:** Основной файл приложения, который демонстрирует работу всех паттернов проектирования.

**Структура файла:**

1. **Инициализация инвентаря** (строка 11)
2. **Демонстрация Abstract Factory Pattern** (строки 13-32)
3. **Демонстрация Builder Pattern** (строки 34-41)
4. **Создание различных типов предметов** (строки 43-51)
5. **Демонстрация Strategy Pattern** (строки 53-66)
6. **Улучшение предметов** (строки 68-72)
7. **Демонстрация State Pattern** (строки 74-82)
8. **Финальное состояние инвентаря** (строки 84-86)

#### Инициализация инвентаря

```csharp
var inventory = new Inventory();
```

**Объяснение:** Создается объект `Inventory` для управления коллекцией предметов.

#### Демонстрация Abstract Factory Pattern

```csharp
Console.WriteLine("--- 1. Проверяем работу Abstract Factory Pattern ---");
Console.WriteLine("Создание предметов через NoviceItemFactory:");
IItemFactory noviceFactory = new NoviceItemFactory();
var noviceWeapon = noviceFactory.CreateWeapon();
var noviceArmor = noviceFactory.CreateArmor();
var novicePotion = noviceFactory.CreatePotion();
inventory.AddItem(noviceWeapon);
inventory.AddItem(noviceArmor);
inventory.AddItem(novicePotion);
```

**Объяснение:**

- Создается фабрика `NoviceItemFactory` для создания предметов для новичков
- Фабрика создает оружие, броню и зелье с характеристиками для новичков
- Все предметы добавляются в инвентарь
- Аналогично создаются предметы через `MageItemFactory` для магов

#### Демонстрация Builder Pattern

```csharp
Console.WriteLine("--- 2. Проверяем работу Builder Pattern ---");
Console.WriteLine("Создание оружия через WeaponBuilder:");
var customSword = new WeaponBuilder()
    .SetName("Легендарный меч")
    .SetDamage(50)
    .Build();
inventory.AddItem(customSword);
```

**Объяснение:**

- Используется `WeaponBuilder` для пошагового создания оружия
- Методы `SetName()` и `SetDamage()` возвращают сам билдер (Fluent Interface)
- Метод `Build()` проверяет валидность данных и возвращает готовый объект
- Созданное оружие добавляется в инвентарь

#### Демонстрация Strategy Pattern

```csharp
Console.WriteLine("--- 4. Strategy Pattern ---");
Console.WriteLine("Использование EquipStrategy:");
inventory.UseItem("Простой меч", new EquipStrategy());
inventory.UseItem("Легендарный меч", new EquipStrategy());

Console.WriteLine("Использование DrinkStrategy:");
inventory.UseItem("Малое зелье", new DrinkStrategy());
inventory.UseItem("Эликсир маны", new DrinkStrategy());

Console.WriteLine("Использование NoUseStrategy:");
inventory.UseItem("Древний артефакт", new NoUseStrategy());
```

**Объяснение:**

- Демонстрируются разные стратегии использования предметов
- `EquipStrategy` - для экипировки оружия и брони
- `DrinkStrategy` - для выпивания зелий
- `NoUseStrategy` - для предметов, которые нельзя использовать
- Один и тот же метод `UseItem()` работает с разными стратегиями

#### Демонстрация State Pattern

```csharp
Console.WriteLine("--- 6. State Pattern (состояния предметов) ---");
Console.WriteLine("Использование предмета несколько раз для демонстрации изменения состояния:");
inventory.UseItem("Простой меч", new EquipStrategy());
inventory.UseItem("Простой меч", new EquipStrategy());
Console.WriteLine("Третье использование (предмет сломается):");
inventory.UseItem("Простой меч", new EquipStrategy());
Console.WriteLine("Починка предмета через улучшение:");
inventory.UpgradeItem("Простой меч");
```

**Объяснение:**

- Предмет используется несколько раз, демонстрируя переходы состояний
- После первого использования: Новый → Использованный
- После третьего использования: Использованный → Сломанный
- При улучшении сломанного предмета: Сломанный → Новый (починка)

### Файл `Item.cs` - абстрактный базовый класс

**Назначение:** Абстрактный базовый класс для всех типов предметов, определяющий общую структуру и функциональность с поддержкой паттерна State.

#### Свойства класса

```csharp
public string? Name { get; set; }
public int Level { get; set; } = 1;
public int UseCount { get; set; } = 0;
private IItemState _state;
```

**Объяснение:**

- `Name` - название предмета (nullable, может быть `null`)
- `Level` - уровень предмета, инициализируется значением 1
- `UseCount` - счетчик использований, инициализируется значением 0
- `_state` - приватное поле для хранения текущего состояния предмета (паттерн State)

#### Конструктор

```csharp
protected Item()
{
    _state = new NewState();
}
```

**Объяснение:**

- `protected` означает, что конструктор доступен только внутри класса `Item` и его производных классов
- При создании предмета устанавливается начальное состояние `NewState` (новый предмет)
- Это предотвращает создание объектов `Item` напрямую (так как класс абстрактный)

#### Методы работы с состоянием

```csharp
public IItemState GetState()
{
    return _state;
}

public void ChangeState(IItemState newState)
{
    _state = newState;
}

public string GetStateName()
{
    return _state.GetStateName();
}
```

**Объяснение:**

- `GetState()` - возвращает текущее состояние предмета
- `ChangeState()` - изменяет состояние предмета на новое (вызывается из состояний)
- `GetStateName()` - возвращает строковое название текущего состояния

#### Метод улучшения

```csharp
public void Upgrade()
{
    _state.Upgrade(this);
}
```

**Объяснение:**

- Делегирует улучшение текущему состоянию через паттерн State
- Каждое состояние реализует свою логику улучшения
- `this` передается в состояние для доступа к свойствам предмета

#### Абстрактный метод

```csharp
public abstract void Use();
```

**Объяснение:**

- `abstract` означает, что метод не имеет реализации в этом классе
- Производные классы (`Weapon`, `Armor`, `Potion`, `QuestItem`) **обязаны** реализовать этот метод
- Каждый тип предмета имеет свою логику использования

### Файл `Weapon.cs` - класс для оружия

**Назначение:** Класс для представления оружия, наследующийся от `Item`.

#### Свойство класса

```csharp
public int Damage { get; set; }
```

**Объяснение:** Дополнительное свойство, специфичное для оружия. Хранит урон оружия.

#### Переопределение метода Use

```csharp
public override void Use()
{
    Console.WriteLine($"Вы экипировали оружие {Name} с уроном {Damage}");
    GetState().Use(this);
}
```

**Объяснение:**

- `override` означает, что этот метод заменяет абстрактный метод из базового класса
- Выводит сообщение об экипировке оружия
- Вызывает метод `Use()` текущего состояния, передавая себя (`this`)
- Состояние само решает, как обработать использование и нужно ли изменить состояние

### Файл `Armor.cs` - класс для брони

**Назначение:** Класс для представления брони, наследующийся от `Item`.

#### Свойство класса

```csharp
public int Defense { get; set; }
```

**Объяснение:** Дополнительное свойство, специфичное для брони. Хранит защиту брони.

#### Переопределение метода Use

```csharp
public override void Use()
{
    Console.WriteLine($"Вы экипировали броню {Name} с защитой {Defense}");
    GetState().Use(this);
}
```

**Объяснение:** Аналогично `Weapon`, но выводит информацию о защите вместо урона.

### Файл `Potion.cs` - класс для зелий

**Назначение:** Класс для представления зелий, наследующийся от `Item`.

#### Свойство класса

```csharp
public string? Effect { get; set; }
```

**Объяснение:** Дополнительное свойство, специфичное для зелий. Хранит описание эффекта зелья (например, "+20 HP").

#### Переопределение метода Use

```csharp
public override void Use()
{
    Console.WriteLine($"Вы использовали зелье: {Effect}");
    GetState().Use(this);
}
```

**Объяснение:** Выводит информацию об использовании зелья и его эффекте.

### Файл `QuestItem.cs` - класс для квестовых предметов

**Назначение:** Класс для представления квестовых предметов, наследующийся от `Item`.

#### Свойство класса

```csharp
public string? QuestDescription { get; set; }
```

**Объяснение:** Дополнительное свойство для описания квеста, связанного с предметом.

#### Переопределение метода Use

```csharp
public override void Use()
{
    if (!string.IsNullOrEmpty(QuestDescription))
    {
        Console.WriteLine($"Квестовый предмет {Name}: {QuestDescription}");
        Console.WriteLine("Этот предмет нельзя использовать напрямую. Он нужен для выполнения квеста.");
    }
    else
    {
        Console.WriteLine($"Квестовый предмет {Name} нельзя использовать. Он нужен для выполнения квеста.");
    }
}
```

**Объяснение:**

- Квестовые предметы не вызывают `GetState().Use(this)`, так как они не меняют состояние при использовании
- Выводит информацию о квесте, если описание задано
- Информирует, что предмет нельзя использовать напрямую

### Файл `Inventory.cs` - менеджер инвентаря

**Назначение:** Основной класс для управления коллекцией предметов с поддержкой паттерна Strategy.

#### Поле класса

```csharp
private List<Item> items = new List<Item>();
```

**Объяснение:**

- `private` - поле доступно только внутри класса
- `List<Item>` - список для хранения всех предметов в инвентаре
- Инициализируется пустым списком

#### Метод добавления предмета

```csharp
public void AddItem(Item item)
{
    items.Add(item);
    Console.WriteLine($"{item.Name} добавлен в инвентарь");
}
```

**Объяснение:**

- Добавляет предмет в список
- Выводит сообщение о добавлении предмета

#### Метод отображения всех предметов

```csharp
public void ShowItems()
{
    Console.WriteLine("--- Инвентарь ---");
    foreach (var item in items)
    {
        Console.WriteLine($"{item.Name}, уровень {item.Level}, состояние: {item.GetStateName()}");
    }
}
```

**Объяснение:**

- Выводит заголовок
- Перебирает все предметы в инвентаре
- Для каждого предмета выводит имя, уровень и текущее состояние

#### Метод использования предмета (Strategy Pattern)

```csharp
public void UseItem(string name, IUseStrategy strategy)
{
    Item? item = null;
    foreach (var i in items)
    {
        if (i.Name == name)
        {
            item = i;
            break;
        }
    }
    if (item != null)
        strategy.Execute(item);
    else
        Console.WriteLine("Предмет не найден");
}
```

**Объяснение:**

- Принимает имя предмета и стратегию использования (`IUseStrategy`)
- Ищет предмет по имени в списке
- Если предмет найден, вызывает метод `Execute()` стратегии
- Если предмет не найден, выводит сообщение об ошибке
- Это демонстрация паттерна Strategy: один метод работает с разными стратегиями

#### Метод улучшения предмета

```csharp
public void UpgradeItem(string name)
{
    Item? item = null;
    foreach (var i in items)
    {
        if (i.Name == name)
        {
            item = i;
            break;
        }
    }
    item?.Upgrade();
}
```

**Объяснение:**

- Ищет предмет по имени
- Использует оператор `?.` (null-conditional) для безопасного вызова `Upgrade()`
- Если предмет найден, вызывается метод улучшения, который делегирует работу текущему состоянию

### Файл `IUseStrategy.cs` - интерфейс стратегии использования

**Назначение:** Определяет контракт для стратегий использования предметов (паттерн Strategy).

```csharp
public interface IUseStrategy
{
    void Execute(Item item);
}
```

**Объяснение:**

- Интерфейс определяет один метод `Execute()`, который принимает предмет
- Все стратегии должны реализовать этот интерфейс
- Позволяет использовать разные стратегии в одном месте кода

### Файл `EquipStrategy.cs` - стратегия экипировки

**Назначение:** Реализация стратегии для экипировки оружия и брони.

```csharp
public class EquipStrategy : IUseStrategy
{
    public void Execute(Item item)
    {
        if (item is Weapon || item is Armor)
        {
            item.Use();
            Console.WriteLine($"Предмет {item.Name} экипирован");
        }
        else
        {
            Console.WriteLine($"Предмет {item.Name} нельзя экипировать");
        }
    }
}
```

**Объяснение:**

- Проверяет, является ли предмет оружием или броней
- Если да, вызывает метод `Use()` предмета и выводит сообщение об экипировке
- Если нет, выводит сообщение, что предмет нельзя экипировать

### Файл `DrinkStrategy.cs` - стратегия выпивания

**Назначение:** Реализация стратегии для выпивания зелий.

```csharp
public class DrinkStrategy : IUseStrategy
{
    public void Execute(Item item)
    {
        if (item is Potion potion)
        {
            item.Use();
            Console.WriteLine($"Зелье {item.Name} использовано, эффект применен");
        }
        else
        {
            Console.WriteLine($"Предмет {item.Name} не является зельем");
        }
    }
}
```

**Объяснение:**

- Использует pattern matching (`item is Potion potion`) для проверки типа
- Если предмет является зельем, вызывает метод `Use()` и выводит сообщение
- Если нет, выводит сообщение об ошибке

### Файл `NoUseStrategy.cs` - стратегия "нельзя использовать"

**Назначение:** Реализация стратегии для предметов, которые нельзя использовать.

```csharp
public class NoUseStrategy : IUseStrategy
{
    public void Execute(Item item)
    {
        Console.WriteLine("Этот предмет нельзя использовать");
    }
}
```

**Объяснение:** Простая стратегия, которая просто выводит сообщение о том, что предмет нельзя использовать. Используется для квестовых предметов.

### Файл `IItemState.cs` - интерфейс состояния предмета

**Назначение:** Определяет контракт для состояний предметов (паттерн State).

```csharp
public interface IItemState
{
    void Use(Item item);
    void Upgrade(Item item);
    string GetStateName();
}
```

**Объяснение:**

- `Use()` - метод для обработки использования предмета в данном состоянии
- `Upgrade()` - метод для обработки улучшения предмета в данном состоянии
- `GetStateName()` - возвращает строковое название состояния
- Все состояния должны реализовать этот интерфейс

### Файл `NewState.cs` - состояние "Новый"

**Назначение:** Реализация состояния для нового предмета.

#### Метод Use

```csharp
public void Use(Item item)
{
    Console.WriteLine($"Предмет {item.Name} используется (новый)");
    item.UseCount++;
    item.ChangeState(new UsedState());
}
```

**Объяснение:**

- Выводит сообщение об использовании нового предмета
- Увеличивает счетчик использований
- Меняет состояние предмета на `UsedState` (Новый → Использованный)

#### Метод Upgrade

```csharp
public void Upgrade(Item item)
{
    item.Level++;
    Console.WriteLine($"{item.Name} улучшен до уровня {item.Level} (новый)");
}
```

**Объяснение:**

- Увеличивает уровень предмета
- Выводит сообщение об улучшении нового предмета
- Состояние не меняется при улучшении нового предмета

### Файл `UsedState.cs` - состояние "Использованный"

**Назначение:** Реализация состояния для использованного предмета.

#### Метод Use

```csharp
public void Use(Item item)
{
    Console.WriteLine($"Предмет {item.Name} используется (уже был в использовании)");
    item.UseCount++;
    if (item.UseCount >= 3)
    {
        Console.WriteLine($"Предмет {item.Name} сломался от износа после {item.UseCount} использований!");
        item.ChangeState(new BrokenState());
    }
}
```

**Объяснение:**

- Выводит сообщение об использовании уже использованного предмета
- Увеличивает счетчик использований
- Если предмет использован 3 или более раз, меняет состояние на `BrokenState` (Использованный → Сломанный)

#### Метод Upgrade

```csharp
public void Upgrade(Item item)
{
    item.Level++;
    Console.WriteLine($"{item.Name} улучшен до уровня {item.Level} (использованный)");
}
```

**Объяснение:** Аналогично `NewState`, но выводит сообщение для использованного предмета.

### Файл `BrokenState.cs` - состояние "Сломанный"

**Назначение:** Реализация состояния для сломанного предмета.

#### Метод Use

```csharp
public void Use(Item item)
{
    Console.WriteLine($"Предмет {item.Name} сломан и не может быть использован!");
}
```

**Объяснение:**

- Сломанный предмет нельзя использовать
- Просто выводит сообщение об ошибке
- Состояние не меняется

#### Метод Upgrade

```csharp
public void Upgrade(Item item)
{
    Console.WriteLine($"Предмет {item.Name} починен и восстановлен! Счетчик использований сброшен.");
    item.UseCount = 0;
    item.ChangeState(new NewState());
}
```

**Объяснение:**

- При улучшении сломанный предмет чинится
- Сбрасывается счетчик использований в 0
- Меняет состояние на `NewState` (Сломанный → Новый)
- Это демонстрирует цикл состояний: Новый → Использованный → Сломанный → Новый

### Файл `WeaponBuilder.cs` - строитель оружия

**Назначение:** Реализация паттерна Builder для пошагового создания оружия с валидацией.

#### Поле класса

```csharp
private Weapon weapon = new Weapon();
```

**Объяснение:** Приватное поле для хранения создаваемого оружия. Инициализируется пустым объектом `Weapon`.

#### Метод SetName

```csharp
public WeaponBuilder SetName(string name)
{
    weapon.Name = name;
    return this;
}
```

**Объяснение:**

- Устанавливает имя оружия
- Возвращает `this` (сам билдер) для поддержки цепочки вызовов (Fluent Interface)
- Позволяет писать: `builder.SetName("Меч").SetDamage(50)`

#### Метод SetDamage

```csharp
public WeaponBuilder SetDamage(int dmg)
{
    weapon.Damage = dmg;
    return this;
}
```

**Объяснение:** Аналогично `SetName()`, но устанавливает урон оружия.

#### Метод Build

```csharp
public Weapon Build()
{
    if (string.IsNullOrEmpty(weapon.Name))
    {
        throw new InvalidOperationException("Имя оружия не может быть пустым");
    }
    if (weapon.Damage <= 0)
    {
        throw new InvalidOperationException("Урон оружия должен быть положительным числом");
    }
    return weapon;
}
```

**Объяснение:**

- Проверяет валидность данных перед возвратом объекта
- Если имя пустое, выбрасывает исключение
- Если урон неположительный, выбрасывает исключение
- Если все проверки пройдены, возвращает готовый объект `Weapon`
- Гарантирует, что нельзя создать невалидный объект

### Файл `IItemFactory.cs` - интерфейс фабрики предметов

**Назначение:** Определяет контракт для фабрик создания предметов (паттерн Abstract Factory).

```csharp
public interface IItemFactory
{
    Weapon CreateWeapon();
    Armor CreateArmor();
    Potion CreatePotion();
}
```

**Объяснение:**

- Интерфейс определяет методы для создания трех типов предметов
- Все фабрики должны реализовать эти методы
- Позволяет создавать семейства связанных предметов

### Файл `NoviceItemFactory.cs` - фабрика для новичков

**Назначение:** Реализация фабрики для создания предметов для новичков.

```csharp
public class NoviceItemFactory : IItemFactory
{
    public Weapon CreateWeapon()
    {
        return new Weapon() { Name = "Простой меч", Damage = 5 };
    }

    public Armor CreateArmor()
    {
        return new Armor() { Name = "Кожаная броня", Defense = 2 };
    }

    public Potion CreatePotion()
    {
        return new Potion() { Name = "Малое зелье", Effect = "+20 HP" };
    }
}
```

**Объяснение:**

- Создает простые предметы с низкими характеристиками
- Оружие: "Простой меч" с уроном 5
- Броня: "Кожаная броня" с защитой 2
- Зелье: "Малое зелье" с эффектом "+20 HP"
- Все предметы создаются с начальными значениями (Level = 1, UseCount = 0)

### Файл `MageItemFactory.cs` - фабрика для магов

**Назначение:** Реализация фабрики для создания предметов для магов.

```csharp
public class MageItemFactory : IItemFactory
{
    public Weapon CreateWeapon()
    {
        return new Weapon() { Name = "Посох мага", Damage = 12 };
    }

    public Armor CreateArmor()
    {
        return new Armor() { Name = "Мантия мага", Defense = 3 };
    }

    public Potion CreatePotion()
    {
        return new Potion() { Name = "Эликсир маны", Effect = "+30 MP" };
    }
}
```

**Объяснение:**

- Создает более сильные предметы для магов
- Оружие: "Посох мага" с уроном 12
- Броня: "Мантия мага" с защитой 3
- Зелье: "Эликсир маны" с эффектом "+30 MP"
- Демонстрирует, как одна фабрика создает связанное семейство предметов

## Паттерны проектирования в проекте

### 1. Strategy Pattern (Паттерн Стратегия)

**Определение:** Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Позволяет выбирать алгоритм во время выполнения.

**Реализация в проекте:**

- **Интерфейс:** `IUseStrategy` с методом `Execute(Item item)`
- **Реализации:**
  - `EquipStrategy` - для экипировки оружия и брони
  - `DrinkStrategy` - для выпивания зелий
  - `NoUseStrategy` - для предметов, которые нельзя использовать
- **Использование:** В методе `Inventory.UseItem(string name, IUseStrategy strategy)`

**Преимущества:**

- Можно добавлять новые стратегии без изменения `Inventory`
- Легко тестировать каждую стратегию отдельно
- Соблюдает принцип Open/Closed (открыт для расширения, закрыт для модификации)

**Пример использования:**

```csharp
inventory.UseItem("Простой меч", new EquipStrategy());    // Экипировка
inventory.UseItem("Малое зелье", new DrinkStrategy());    // Выпивание
inventory.UseItem("Артефакт", new NoUseStrategy());       // Нельзя использовать
```

### 2. State Pattern (Паттерн Состояние)

**Определение:** Позволяет объекту изменять свое поведение при изменении внутреннего состояния. Объект будет вести себя как будто изменил свой класс.

**Реализация в проекте:**

- **Интерфейс:** `IItemState` с методами `Use()`, `Upgrade()`, `GetStateName()`
- **Реализации:**
  - `NewState` - новый предмет
  - `UsedState` - использованный предмет
  - `BrokenState` - сломанный предмет
- **Использование:** В классе `Item` через поле `private IItemState _state`

**Диаграмма переходов состояний:**

```
     Новый (NewState)
        │
        │ Use()
        ▼
  Использованный (UsedState)
        │
        │ Use() (3 раза)
        ▼
    Сломанный (BrokenState)
        │
        │ Upgrade()
        ▼
     Новый (NewState)
```

**Преимущества:**

- Избегает больших условных операторов (if-else)
- Легко добавлять новые состояния
- Поведение предмета зависит от его состояния
- Каждое состояние инкапсулирует свою логику

**Пример использования:**

```csharp
var weapon = new Weapon() { Name = "Меч", Damage = 10 };
weapon.Use();  // Новый → Использованный
weapon.Use();  // Использованный (UseCount = 2)
weapon.Use();  // Использованный → Сломанный (UseCount = 3)
weapon.Upgrade();  // Сломанный → Новый (починка)
```

### 3. Builder Pattern (Паттерн Строитель)

**Определение:** Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления.

**Реализация в проекте:**

- **Класс:** `WeaponBuilder`
- **Методы:**
  - `SetName(string name)` - устанавливает имя
  - `SetDamage(int dmg)` - устанавливает урон
  - `Build()` - создает объект с валидацией
- **Особенность:** Fluent Interface (цепочка вызовов) через `return this`

**Преимущества:**

- Пошаговое создание объекта
- Валидация данных перед созданием
- Удобный синтаксис (Fluent Interface)
- Нельзя создать невалидный объект

**Пример использования:**

```csharp
var sword = new WeaponBuilder()
    .SetName("Легендарный меч")
    .SetDamage(50)
    .Build();
```

### 4. Abstract Factory Pattern (Паттерн Абстрактная Фабрика)

**Определение:** Предоставляет интерфейс для создания семейств связанных или зависимых объектов без указания их конкретных классов.

**Реализация в проекте:**

- **Интерфейс:** `IItemFactory` с методами `CreateWeapon()`, `CreateArmor()`, `CreatePotion()`
- **Реализации:**
  - `NoviceItemFactory` - создает простые предметы для новичков
  - `MageItemFactory` - создает предметы для магов
- **Использование:** В `Program.cs` для создания предметов разных типов персонажей

**Преимущества:**

- Создание связанных объектов (семейств)
- Легко добавлять новые семейства (например, `WarriorItemFactory`)
- Изоляция создания объектов от использования
- Соблюдает принцип Dependency Inversion

**Пример использования:**

```csharp
IItemFactory noviceFactory = new NoviceItemFactory();
var weapon = noviceFactory.CreateWeapon();  // Простой меч
var armor = noviceFactory.CreateArmor();    // Кожаная броня
var potion = noviceFactory.CreatePotion();   // Малое зелье
```

## Принципы SOLID в проекте

### S - Single Responsibility Principle (Принцип единственной ответственности)

**Определение:** Класс должен иметь только одну причину для изменения.

**Примеры в проекте:**

- **`Inventory`** - отвечает только за управление коллекцией предметов (добавление, поиск, отображение)
- **`NewState`** - отвечает только за поведение предмета в состоянии "Новый"
- **`EquipStrategy`** - отвечает только за логику экипировки предметов
- **`WeaponBuilder`** - отвечает только за создание оружия с валидацией

### O - Open/Closed Principle (Принцип открытости/закрытости)

**Определение:** Классы должны быть открыты для расширения, но закрыты для модификации.

**Примеры в проекте:**

- **Strategy Pattern:** Можно добавлять новые стратегии (`SellStrategy`, `DisassembleStrategy`) без изменения `Inventory`
- **State Pattern:** Можно добавлять новые состояния (`RepairedState`, `EnchantedState`) без изменения `Item`
- **Abstract Factory:** Можно добавлять новые фабрики (`WarriorItemFactory`) без изменения интерфейса `IItemFactory`

**Пример:**

```csharp
// Можно добавить новую стратегию БЕЗ изменения Inventory
public class SellStrategy : IUseStrategy
{
    public void Execute(Item item)
    {
        Console.WriteLine($"Предмет {item.Name} продан");
    }
}

// Использование:
inventory.UseItem("Меч", new SellStrategy());  // Работает сразу!
```

### L - Liskov Substitution Principle (Принцип подстановки Лисков)

**Определение:** Объекты в программе должны заменяться экземплярами их подтипов без изменения правильности выполнения программы.

**Примеры в проекте:**

- **Наследование от `Item`:** `Weapon`, `Armor`, `Potion`, `QuestItem` могут использоваться везде, где ожидается `Item`
- **Реализации `IItemState`:** `NewState`, `UsedState`, `BrokenState` взаимозаменяемы
- **Реализации `IUseStrategy`:** `EquipStrategy`, `DrinkStrategy`, `NoUseStrategy` взаимозаменяемы

**Пример:**

```csharp
List<Item> items = new List<Item>();
items.Add(new Weapon());    // ✅ Работает
items.Add(new Armor());     // ✅ Работает
items.Add(new Potion());    // ✅ Работает
items.Add(new QuestItem()); // ✅ Работает
```

### I - Interface Segregation Principle (Принцип разделения интерфейса)

**Определение:** Клиенты не должны зависеть от методов, которые они не используют.

**Примеры в проекте:**

- **`IUseStrategy`** - содержит только один метод `Execute()`, который используется всеми стратегиями
- **`IItemState`** - содержит три метода (`Use()`, `Upgrade()`, `GetStateName()`), все используются состояниями
- **`IItemFactory`** - содержит три метода (`CreateWeapon()`, `CreateArmor()`, `CreatePotion()`), все используются фабриками

**Преимущества:**

- Интерфейсы маленькие и сфокусированные
- Классы не обязаны реализовывать ненужные методы
- Легко понять назначение интерфейса

### D - Dependency Inversion Principle (Принцип инверсии зависимостей)

**Определение:** Зависимости должны быть на абстракциях, а не на конкретных реализациях.

**Примеры в проекте:**

- **`Inventory`** зависит от `IUseStrategy` (интерфейс), а не от конкретных стратегий
- **`Item`** зависит от `IItemState` (интерфейс), а не от конкретных состояний
- **`Program`** использует `IItemFactory` (интерфейс), а не конкретные фабрики

**Пример:**

```csharp
// Inventory зависит от интерфейса, а не от конкретных классов
public void UseItem(string name, IUseStrategy strategy)  // ← Интерфейс!
{
    // ...
    strategy.Execute(item);  // Работает с любой реализацией
}
```

**Преимущества:**

- Можно легко заменять реализации
- Код гибкий и расширяемый
- Легко тестировать (можно использовать моки)

## Unit тестирование

Проект включает **более 30 unit тестов**, написанных с использованием фреймворка xUnit, которые покрывают всю функциональность системы:

### Тесты для предметов

- **`WeaponTests`** (2 теста):

  - `Weapon_ShouldCreateWithProperties` - проверяет корректное создание оружия
  - `Weapon_Use_ShouldChangeState` - проверяет изменение состояния при использовании

- **`ArmorTests`** (2 теста):

  - `Armor_ShouldCreateWithProperties` - проверяет корректное создание брони
  - `Armor_Use_ShouldChangeState` - проверяет изменение состояния при использовании

- **`PotionTests`** (2 теста):

  - `Potion_ShouldCreateWithProperties` - проверяет корректное создание зелья
  - `Potion_Use_ShouldChangeState` - проверяет изменение состояния при использовании

- **`QuestItemTests`** (2 теста):
  - `QuestItem_ShouldCreateWithProperties` - проверяет корректное создание квестового предмета
  - `QuestItem_Use_ShouldNotChangeState` - проверяет, что состояние не меняется

### Тесты для инвентаря

- **`InventoryTests`** (5 тестов):
  - `Inventory_AddItem_ShouldAddItem` - проверяет добавление предмета
  - `Inventory_ShowItems_ShouldDisplayItems` - проверяет отображение предметов
  - `Inventory_UseItem_ShouldUseItem` - проверяет использование предмета
  - `Inventory_UpgradeItem_ShouldUpgradeItem` - проверяет улучшение предмета
  - `Inventory_UseItem_WithNonExistentItem_ShouldNotFail` - проверяет обработку несуществующего предмета

### Тесты для стратегий

- **`EquipStrategyTests`** (3 теста):

  - `EquipStrategy_WithWeapon_ShouldEquip` - проверяет экипировку оружия
  - `EquipStrategy_WithArmor_ShouldEquip` - проверяет экипировку брони
  - `EquipStrategy_WithPotion_ShouldNotEquip` - проверяет, что зелье нельзя экипировать

- **`DrinkStrategyTests`** (3 теста):

  - `DrinkStrategy_WithPotion_ShouldDrink` - проверяет выпивание зелья
  - `DrinkStrategy_WithWeapon_ShouldNotDrink` - проверяет, что оружие нельзя выпить
  - `DrinkStrategy_WithArmor_ShouldNotDrink` - проверяет, что броню нельзя выпить

- **`NoUseStrategyTests`** (1 тест):
  - `NoUseStrategy_ShouldNotChangeState` - проверяет, что стратегия не меняет состояние

### Тесты для Builder

- **`WeaponBuilderTests`** (4 теста):
  - `WeaponBuilder_ShouldBuildWeapon` - проверяет создание оружия через билдер
  - `WeaponBuilder_ShouldThrowOnEmptyName` - проверяет исключение при пустом имени
  - `WeaponBuilder_ShouldThrowOnZeroDamage` - проверяет исключение при нулевом уроне
  - `WeaponBuilder_ShouldThrowOnNegativeDamage` - проверяет исключение при отрицательном уроне

### Тесты для Abstract Factory

- **`NoviceItemFactoryTests`** (3 теста):

  - `NoviceItemFactory_ShouldCreateWeapon` - проверяет создание оружия
  - `NoviceItemFactory_ShouldCreateArmor` - проверяет создание брони
  - `NoviceItemFactory_ShouldCreatePotion` - проверяет создание зелья

- **`MageItemFactoryTests`** (3 теста):
  - `MageItemFactory_ShouldCreateWeapon` - проверяет создание оружия мага
  - `MageItemFactory_ShouldCreateArmor` - проверяет создание брони мага
  - `MageItemFactory_ShouldCreatePotion` - проверяет создание зелья мага

### Тесты для состояний

- **`NewStateTests`** (2 теста):

  - `NewState_Use_ShouldChangeToUsedState` - проверяет переход в UsedState
  - `NewState_Upgrade_ShouldIncreaseLevel` - проверяет увеличение уровня

- **`UsedStateTests`** (3 теста):

  - `UsedState_Use_ShouldIncrementUseCount` - проверяет увеличение счетчика
  - `UsedState_Use_AfterThreeUses_ShouldChangeToBrokenState` - проверяет переход в BrokenState после 3 использований
  - `UsedState_Upgrade_ShouldIncreaseLevel` - проверяет увеличение уровня

- **`BrokenStateTests`** (3 теста):
  - `BrokenState_Use_ShouldNotChangeState` - проверяет, что сломанный предмет нельзя использовать
  - `BrokenState_Upgrade_ShouldRepairItem` - проверяет починку предмета
  - `BrokenState_Upgrade_ShouldResetUseCount` - проверяет сброс счетчика использований

### Интеграционные тесты

- **`IntegrationTests`** (2 теста):
  - `Integration_WeaponBuilderWithFactory_ShouldWork` - проверяет совместную работу Builder и Factory
  - `Integration_StateTransitions_ShouldWork` - проверяет полный цикл переходов состояний

### Запуск тестов

Для запуска всех тестов используется команда:

```bash
dotnet test
```

Для запуска с подробным выводом:

```bash
dotnet test --verbosity detailed
```

## Обработка ошибок и валидация

- **Валидация в Builder:** `WeaponBuilder.Build()` проверяет, что имя не пустое и урон положительный, выбрасывая исключения при ошибках
- **Проверка существования предметов:** `Inventory.UseItem()` и `Inventory.UpgradeItem()` проверяют наличие предмета перед использованием
- **Безопасные вызовы:** Использование оператора `?.` (null-conditional) для безопасного вызова методов
- **Информативные сообщения:** При ошибках пользователь получает понятные сообщения (например, "Предмет не найден")
- **Защита от невалидных состояний:** Состояния проверяют условия перед изменением состояния (например, `UseCount >= 3`)

## Используемые технологии и библиотеки

- **C# .NET 10.0** - основной язык и платформа
- **xUnit** - фреймворк для unit тестирования
- **Console I/O** - для вывода информации в консоль
- **Implicit Usings** - автоматический импорт базовых пространств имен

## Итоги

Система демонстрирует комплексное использование паттернов проектирования и принципов SOLID:

- **Strategy Pattern** для выбора алгоритма использования предметов во время выполнения
- **State Pattern** для управления состояниями предметов и изменения их поведения
- **Builder Pattern** для пошагового создания объектов с валидацией
- **Abstract Factory Pattern** для создания семейств связанных предметов

Проект полностью покрыт unit тестами (более 30 тестов), что обеспечивает надежность и поддерживаемость кода. Код написан с соблюдением принципов SOLID, что делает его гибким, расширяемым и легко тестируемым.
